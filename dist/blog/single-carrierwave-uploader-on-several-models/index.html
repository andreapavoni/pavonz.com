<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pavonz.com</title>
    <link rel="stylesheet" href="https://pavonz.com/app.css" />
  </head>
  <body>
    <header class="root">
      <section class="container">
        <nav>
          <ul>
            <li><a href="/">home</a></li>
            <li><a href="/blog">blog</a></li>
          </ul>
        </nav>
        <h1><a href="/">~/pavonz</a></h1>
      </section>
    </header>

    <main class="container">
<h1 class="title">Using one carrierwave image uploader with different sizes on several models</h1>
<p class="subtitle"><strong>2012-03-19</strong></p>
<p>First of all, a typical use case:</p>
<ul>
<li>2 or more models with some image to upload, each model needs different image sizes. For example, you might need images for user's avatar, photo galleries and/or screenshots.</li>
<li>using the awesome <a href="https://github.com/jnicklas/carrierwave">carrierwave</a> gem</li>
</ul>
<p>The <em>common</em> solution is to have several <em>image uploaders</em>, often with fancy names to distinguish them. I didn't like this approach, so why don't use some metaprogramming? ;-)</p>
<p>I've used this solution on a commercial project with enough satisfaction, the mayor advantages are:</p>
<ul>
<li>DRY code: it doesn't make sense to have several <em>image uploaders</em> just because you need different sizes on each model</li>
<li>embrace conventions: you pick some decent <em>version names</em> (eg. <em>thumb</em>, <em>mini</em>, <em>main</em>, and so on) and reuse them contextually to the model.</li>
</ul>
<p>To get an instant picture of what we're going to achieve, here's the custom <code>ImageUploader</code>, I've removed some autogenerated code, you should already know how to use it. Check the comments inside it:</p>
<pre data-lang="ruby" style="background-color:#2b303b;color:#c0c5ce;" class="language-ruby "><code class="language-ruby" data-lang="ruby"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">ImageUploader </span><span style="color:#eff1f5;">&lt; </span><span style="color:#a3be8c;">CarrierWave::Uploader::Base
</span><span>  </span><span style="color:#65737e;"># use mini_magic gem for image processing
</span><span>  </span><span style="color:#8fa1b3;">include </span><span style="color:#ebcb8b;">CarrierWave</span><span>::MiniMagick
</span><span>
</span><span>  </span><span style="color:#65737e;"># call setup_available_size method before cache image
</span><span>  before </span><span style="color:#a3be8c;">:cache</span><span>, </span><span style="color:#a3be8c;">:setup_available_sizes
</span><span>
</span><span>  </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">store_dir
</span><span>    </span><span style="color:#65737e;"># ...
</span><span>  </span><span style="color:#b48ead;">end
</span><span>
</span><span>  </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">default_url
</span><span>    </span><span style="color:#65737e;"># ...
</span><span>  </span><span style="color:#b48ead;">end
</span><span>
</span><span>  </span><span style="color:#65737e;"># we process images with a custom method (read above)
</span><span>  process </span><span style="color:#a3be8c;">:dynamic_resize_to_fit </span><span>=&gt; </span><span style="color:#a3be8c;">:default
</span><span>
</span><span>  </span><span style="color:#65737e;"># default processing, we assume that each model has a &quot;mini&quot; version
</span><span>  version </span><span style="color:#a3be8c;">:mini </span><span style="color:#b48ead;">do
</span><span>    process </span><span style="color:#a3be8c;">:dynamic_resize_to_fit </span><span>=&gt; </span><span style="color:#a3be8c;">:mini
</span><span>  </span><span style="color:#b48ead;">end
</span><span>
</span><span>  </span><span style="color:#65737e;"># conditional processing: we process &quot;thumb&quot; version only if it was defined in model
</span><span>  version </span><span style="color:#a3be8c;">:thumb</span><span>, </span><span style="color:#a3be8c;">:if </span><span>=&gt; </span><span style="color:#a3be8c;">:has_thumb_size? </span><span style="color:#b48ead;">do
</span><span>    process </span><span style="color:#a3be8c;">:dynamic_resize_to_fit </span><span>=&gt; </span><span style="color:#a3be8c;">:thumb
</span><span>  </span><span style="color:#b48ead;">end
</span><span>
</span><span>  </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">extension_white_list
</span><span>    </span><span style="color:#65737e;"># ...
</span><span>  </span><span style="color:#b48ead;">end
</span><span>
</span><span>  </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">sanitize_regexp
</span><span>    </span><span style="color:#65737e;"># ...
</span><span>  </span><span style="color:#b48ead;">end
</span><span>
</span><span>  </span><span style="color:#65737e;"># a lame wrapper to resize_to_fit method
</span><span>  </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">dynamic_resize_to_fit</span><span>(</span><span style="color:#bf616a;">size</span><span>)
</span><span>    resize_to_fit *(model.</span><span style="color:#96b5b4;">class</span><span>::</span><span style="color:#ebcb8b;">IMAGE_SIZES</span><span>[size])
</span><span>  </span><span style="color:#b48ead;">end
</span><span>
</span><span>  </span><span style="color:#65737e;"># here&#39;s the metaprogramming magic!
</span><span>  </span><span style="color:#65737e;"># we check if the called method matches &quot;has_VERSION_size?&quot;
</span><span>  </span><span style="color:#65737e;"># VERSION is a version name for image size
</span><span>  </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">method_missing</span><span>(</span><span style="color:#bf616a;">method</span><span>, *</span><span style="color:#bf616a;">args</span><span>)
</span><span>    </span><span style="color:#65737e;"># we&#39;ve already defined &quot;has_VERSION_size?&quot;, so if a method with
</span><span>    </span><span style="color:#65737e;"># similar name is missed, it should return false
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">false </span><span style="color:#b48ead;">if </span><span style="color:#96b5b4;">method</span><span>.</span><span style="color:#96b5b4;">to_s</span><span>.</span><span style="color:#96b5b4;">match</span><span>(/</span><span style="color:#96b5b4;">has_(.*)_size\?</span><span>/)
</span><span>    </span><span style="color:#b48ead;">super
</span><span>  </span><span style="color:#b48ead;">end
</span><span>
</span><span>  </span><span style="color:#8fa1b3;">protected
</span><span>  </span><span style="color:#65737e;"># the method called at the start
</span><span>  </span><span style="color:#65737e;"># it checks for &lt;model&gt;::IMAGE_SIZES hash and define a custom method &quot;has_VERSION_size?&quot;
</span><span>  </span><span style="color:#65737e;"># (more on this later in the article)
</span><span>  </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">setup_available_sizes</span><span>(</span><span style="color:#bf616a;">file</span><span>)
</span><span>    model.</span><span style="color:#96b5b4;">class</span><span>::</span><span style="color:#ebcb8b;">IMAGE_SIZES</span><span>.keys.each </span><span style="color:#b48ead;">do </span><span>|</span><span style="color:#bf616a;">key</span><span>|
</span><span>      </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">class_eval </span><span style="color:#b48ead;">do
</span><span>        </span><span style="color:#96b5b4;">define_method</span><span>(&quot;</span><span style="color:#a3be8c;">has_</span><span>#{key}</span><span style="color:#a3be8c;">_size?</span><span>&quot;.</span><span style="color:#96b5b4;">to_sym</span><span>) { </span><span style="color:#d08770;">true </span><span>}
</span><span>      </span><span style="color:#b48ead;">end
</span><span>    </span><span style="color:#b48ead;">end
</span><span>  </span><span style="color:#b48ead;">end
</span><span>
</span><span style="color:#b48ead;">end
</span></code></pre>
<p>And now, some models, each with the same <code>ImageUploader</code> and a <code>IMAGE_SIZES</code> Hash containing same keys, but different image sizes:</p>
<pre data-lang="ruby" style="background-color:#2b303b;color:#c0c5ce;" class="language-ruby "><code class="language-ruby" data-lang="ruby"><span style="color:#65737e;"># app/models/photo.rb
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Photo </span><span style="color:#eff1f5;">&lt; </span><span style="color:#a3be8c;">ActiveRecord::Base
</span><span>  </span><span style="color:#65737e;"># custom image sizes: each key is a version name
</span><span>  IMAGE_SIZES = {
</span><span>    </span><span style="color:#a3be8c;">:default </span><span>=&gt; [</span><span style="color:#d08770;">1280</span><span>, </span><span style="color:#d08770;">1280</span><span>],
</span><span>    </span><span style="color:#a3be8c;">:mini </span><span>=&gt; [</span><span style="color:#d08770;">300</span><span>,</span><span style="color:#d08770;">900</span><span>],
</span><span>    </span><span style="color:#a3be8c;">:thumb </span><span>=&gt; [</span><span style="color:#d08770;">100</span><span>, </span><span style="color:#d08770;">300</span><span>]
</span><span>  }
</span><span>
</span><span>  mount_uploader </span><span style="color:#a3be8c;">:image</span><span>, </span><span style="color:#bf616a;">ImageUploader
</span><span>  </span><span style="color:#65737e;"># ...
</span><span style="color:#b48ead;">end
</span><span>
</span><span style="color:#65737e;"># app/models/product.rb
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Product </span><span style="color:#eff1f5;">&lt; </span><span style="color:#a3be8c;">ActiveRecord::Base
</span><span>  </span><span style="color:#65737e;"># other images sizes: same keys, different sizes
</span><span>  IMAGE_SIZES = {
</span><span>    </span><span style="color:#a3be8c;">:default </span><span>=&gt; [</span><span style="color:#d08770;">700</span><span>, </span><span style="color:#d08770;">700</span><span>],
</span><span>    </span><span style="color:#a3be8c;">:mini </span><span>=&gt; [</span><span style="color:#d08770;">300</span><span>,</span><span style="color:#d08770;">300</span><span>],
</span><span>    </span><span style="color:#a3be8c;">:thumb </span><span>=&gt; [</span><span style="color:#d08770;">100</span><span>, </span><span style="color:#d08770;">100</span><span>]
</span><span>  }
</span><span>
</span><span>  mount_uploader </span><span style="color:#a3be8c;">:image</span><span>, </span><span style="color:#bf616a;">ImageUploader
</span><span>  </span><span style="color:#65737e;"># ...
</span><span style="color:#b48ead;">end
</span></code></pre>
<p>As you can see, the key part relies on three methods:</p>
<p><code>setup_available_sizes</code>: it defines some helper methods, according to the versions that where specified in models. That's why it gets called before processing and storage of the uploaded file. Did you notice that this method accepts a <em>file</em> argument? It's not a typo, but it's because Carrierwave always passes that object to its callbacks (check the code <a href="https://github.com/jnicklas/carrierwave/blob/master/lib/carrierwave/uploader/cache.rb#L112">here</a> and <a href="https://github.com/jnicklas/carrierwave/blob/master/lib/carrierwave/uploader/callbacks.rb#L15">here</a>, it's <a href="https://github.com/jnicklas/carrierwave/wiki/How-to%3A-use-callbacks">not documented</a>). If you try to omit it, you'll get a <code>ArgumentError</code>.</p>
<p><code>method_missing</code>: it doesn't need too much explanation (or go to read <a href="http://pragprog.com/book/ppmetr/metaprogramming-ruby">this book</a>, now!), it should be enough to know that in this case, we use it to check if a given model, has defined a particular version (through the <code>setup_available_sizes</code> method we've seen above). In fact, <code>method_missing</code> is called <em>if and only if</em> there isn't a <code>has_VERSION_size?</code> defined. That's why it returns <em>false</em>.</p>
<p><code>dynamic_resize_to_fit</code>: this is a simple wrapper to the carrierwave's <code>resize_to_fit</code> method. Instead of passing <em>width</em> and <em>height</em> values, we pass a <em>version name</em>, so it can lookup the relative sizes from the model. To be honest, this approach is quite lame, because you can use some more <em>motaprogramming fu</em> to dynamically wrap carrierwave's <a href="https://github.com/jnicklas/carrierwave/blob/master/lib/carrierwave/processing/mini_magick.rb">processor methods</a>. Now you have a decent excuse to play with something after you've finished to read ;-)</p>
<p>That's all, folks!</p>
 </main>
    <footer class="root">
      <section class="container">
        <small
          >built with <i class="hearth">&#10084;</i> by Andrea
          <i>pavonz</i> Pavoni &copy;2010-2022</small
        >
      </section>
    </footer>
    <script
      data-goatcounter="https://pavonz.goatcounter.com/count"
      async
      src="//gc.zgo.at/count.js"
    ></script>
  </body>
</html>
